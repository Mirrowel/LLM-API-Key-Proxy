name: Build and Release Executable

on:
  workflow_dispatch:
    inputs:
      manual_previous_tag:
        description: 'Optional: Manually set the previous tag to generate the changelog from.'
        required: false
        default: ''
  push:
    paths:
      - 'src/proxy_app/**'
      - 'src/rotator_library/**'
      - 'launcher.bat'
      - '.github/workflows/build.yml'
      - 'cliff.toml'

jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [windows-latest, ubuntu-latest, macos-latest]
    steps:
    - name: Check out repository
      uses: actions/checkout@v4

    - name: Set up Python
      id: setup-python
      uses: actions/setup-python@v5
      with:
        python-version: '3.12'

    - name: Get pip cache dir
      id: pip-cache
      shell: bash
      run: |
        echo "dir=$(pip cache dir)" >> $GITHUB_OUTPUT

    - name: Cache pip dependencies
      uses: actions/cache@v4
      with:
        path: ${{ steps.pip-cache.outputs.dir }}
        key: ${{ runner.os }}-pip-3.12-${{ hashFiles('requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-3.12

    - name: Install dependencies
      shell: bash
      run: |
        grep -v -- '-e src/rotator_library' requirements.txt > temp_requirements.txt
        pip install -r temp_requirements.txt
        pip install pyinstaller
        pip install -e src/rotator_library

    - name: Cache PyInstaller build data (Windows)
      if: runner.os == 'Windows'
      uses: actions/cache@v4
      with:
        path: $HOME/AppData/Local/pyinstaller
        key: ${{ runner.os }}-pyinstaller-3.12-${{ hashFiles('requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pyinstaller-3.12-

    - name: Cache PyInstaller build data (Linux)
      if: runner.os == 'Linux'
      uses: actions/cache@v4
      with:
        path: $HOME/.cache/pyinstaller
        key: ${{ runner.os }}-pyinstaller-3.12-${{ hashFiles('requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pyinstaller-3.12-

    - name: Cache PyInstaller build data (macOS)
      if: runner.os == 'macOS'
      uses: actions/cache@v4
      with:
        path: $HOME/Library/Application Support/pyinstaller
        key: ${{ runner.os }}-pyinstaller-3.12-${{ hashFiles('requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pyinstaller-3.12-

    - name: Build executable
      run: python src/proxy_app/build.py

    - name: Ensure PyInstaller cache directory exists
      if: runner.os != 'macOS'
      shell: bash
      run: |
        if [ "${{ runner.os }}" == "Windows" ]; then
          mkdir -p "$HOME/AppData/Local/pyinstaller"
        elif [ "${{ runner.os }}" == "Linux" ]; then
          mkdir -p "$HOME/.cache/pyinstaller"
        fi

    - name: Get short SHA
      id: version
      shell: bash
      run: |
        sha=$(git rev-parse --short HEAD)
        echo "sha=$sha" >> $GITHUB_OUTPUT

    - name: Prepare files for artifact
      shell: bash
      run: |
        stagingDir="staging"
        mkdir -p $stagingDir
        cp launcher.bat "$stagingDir/"
        if [ "${{ runner.os }}" == "Windows" ]; then
          cp src/proxy_app/dist/proxy_app.exe "$stagingDir/"
        else
          cp src/proxy_app/dist/proxy_app "$stagingDir/"
        fi
        echo "--- Staging directory contents ---"
        ls -R $stagingDir
        echo "------------------------------------"

    - name: Archive build artifact
      uses: actions/upload-artifact@v4
      with:
        name: proxy-app-build-${{ runner.os }}-${{ steps.version.outputs.sha }}
        path: staging/

  release:
    needs: build
    runs-on: ubuntu-latest
    permissions:
      contents: write
    env:
      WHITELISTED_BRANCHES: "main"
    steps:
    - name: Check out repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Fetch all tags and history
      shell: bash
      run: git fetch --prune --tags

    - name: Get short SHA
      id: get_sha
      shell: bash
      run: echo "sha=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

    - name: Generate Build Version
      id: version
      shell: bash
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        BRANCH_NAME=${{ github.ref_name }}
        DATE_STAMP_NEW=$(date +'%Y%m%d')
        DATE_STAMP_OLD=$(date +'%Y.%m.%d')
        
        # Find the number of releases already created today for this branch, matching either old or new format.
        # We use grep -E for an OR condition and wrap it to prevent failures when no matches are found.
        BUILD_COUNT=$(gh release list --repo "${{ github.repository }}" --limit 100 | { grep -E "$BRANCH_NAME/build-($DATE_STAMP_NEW|$DATE_STAMP_OLD)" || true; } | wc -l)
        
        # Increment the build number for the new release
        BUILD_NUMBER=$((BUILD_COUNT + 1))
        
        # Create the new, sortable version string using the new format
        VERSION="$DATE_STAMP_NEW-$BUILD_NUMBER-${{ steps.get_sha.outputs.sha }}"
        
        # Define all naming components
        echo "release_title=Build ($BRANCH_NAME): $VERSION" >> $GITHUB_OUTPUT
        echo "release_tag=$BRANCH_NAME/build-$VERSION" >> $GITHUB_OUTPUT
        echo "archive_version_part=$BRANCH_NAME-$VERSION" >> $GITHUB_OUTPUT
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "timestamp=$(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_OUTPUT

    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        path: release-assets
        pattern: proxy-app-build-*-${{ steps.get_sha.outputs.sha }}

    - name: Archive release files
      id: archive
      shell: bash
      run: |
        ASSET_PATHS=""
        for dir in release-assets/proxy-app-build-*; do
            if [ -d "$dir" ]; then
                os_name=$(basename "$dir" | cut -d'-' -f4)
                archive_name="LLM-API-Key-Proxy-${os_name}-${{ steps.version.outputs.archive_version_part }}.zip"
                (
                    cd "$dir"
                    zip -r "../../$archive_name" .
                )
                if [ -z "$ASSET_PATHS" ]; then
                    ASSET_PATHS="$archive_name"
                else
                    ASSET_PATHS="$ASSET_PATHS $archive_name"
                fi
            fi
        done
        echo "ASSET_PATHS=$ASSET_PATHS" >> $GITHUB_OUTPUT

    - name: Install git-cliff
      shell: bash
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        API_RESPONSE=$(curl -s -H "Authorization: token $GITHUB_TOKEN" https://api.github.com/repos/orhun/git-cliff/releases/latest)
        LATEST_CLIFF_URL=$(echo "$API_RESPONSE" | jq -r '.assets[] | select(.name | endswith("x86_64-unknown-linux-gnu.tar.gz")) | .browser_download_url')

        if [ -z "$LATEST_CLIFF_URL" ]; then
          echo "::error::Could not find git-cliff asset URL."
          echo "API Response: $API_RESPONSE"
          exit 1
        fi

        curl -L "$LATEST_CLIFF_URL" | tar xz
        sudo mv git-cliff-*/git-cliff /usr/local/bin/

    - name: Prepare git-cliff config
      shell: bash
      run: |
        # Inject the GitHub repo URL into your template
        sed -i "s|{{ repository_url }}|https://github.com/${GITHUB_REPOSITORY}|g" .github/cliff.toml
        echo "✅ cliff.toml:"
        head -20 .github/cliff.toml

    - name: Generate Changelog
      id: changelog
      shell: bash
      run: |
        BRANCH_NAME=${{ github.ref_name }}
        if [ -n "${{ github.event.inputs.manual_previous_tag }}" ]; then
          echo "Manual tag provided: ${{ github.event.inputs.manual_previous_tag }}"
          LAST_TAG="${{ github.event.inputs.manual_previous_tag }}"
        else
          echo "No manual tag, searching for latest tag on branch '$BRANCH_NAME'..."
          
          # Prioritize finding the latest tag with the new format (e.g., build-20250707-1-...).
          echo "Attempting to find latest tag with new format..."
          LAST_TAG=$(git describe --tags --abbrev=0 --match="$BRANCH_NAME/build-[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]-*" 2>/dev/null || true)
          
          # If no new format tag is found, fall back to the old, more generic pattern.
          if [ -z "$LAST_TAG" ]; then
            echo "No new format tag found. Falling back to search for any older build tag..."
            LAST_TAG=$(git describe --tags --abbrev=0 --match="$BRANCH_NAME/build-*" 2>/dev/null || echo "")
          fi
        fi
        
        echo "✅ Using tag: $LAST_TAG"
        
        if [ -n "$LAST_TAG" ]; then
          # Standard run: A previous tag was found.
          echo "🔍 Generating changelog for range: $LAST_TAG..HEAD"
        git-cliff \
          --config .github/cliff.toml \
            --strip all \
            --output changelog.md \
            "$LAST_TAG..HEAD"
        else
          # First run: No previous tag found.
          echo "⚠️ No previous build tag found. Generating initial release changelog."
          echo "## Initial Release" > changelog.md
          echo "" >> changelog.md
          echo "This is the first automated build release using this format. Future releases will contain a detailed list of changes." >> changelog.md
        fi

        # This part of the script remains to handle the output
        if [ -s changelog.md ]; then
          echo "✅ Changelog generated successfully"
          CHANGELOG_B64=$(base64 -w 0 changelog.md)
          echo "changelog_b64=$CHANGELOG_B64" >> $GITHUB_OUTPUT
          echo "has_changelog=true" >> $GITHUB_OUTPUT
          echo "previous_tag=$LAST_TAG" >> $GITHUB_OUTPUT
        else
          # This is now a true error condition
          echo "❌ Critical error: Changelog is empty after generation."
          echo "has_changelog=false" >> $GITHUB_OUTPUT
        fi

    - name: Debug artifact contents
      shell: bash
      run: |
        echo "🔍 Debugging artifact contents..."
        echo "Current directory:"
        pwd
        echo ""
        echo "Release assets directory contents:"
        ls -laR release-assets/ || echo "release-assets directory not found"
        echo ""
        echo "All files in current directory:"
        find . -name "*.zip" | head -20
        echo ""
        echo "Directory structure:"
        find release-assets -type f 2>/dev/null || echo "No files found in release-assets"

    - name: Generate Build Metadata
      id: metadata
      shell: bash
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        # Find executable files and get their sizes
        WINDOWS_EXE=$(find release-assets -name "proxy_app.exe" -type f | head -1)
        if [ -n "$WINDOWS_EXE" ]; then
          WIN_SIZE=$(du -sh "$WINDOWS_EXE" | cut -f1)
        else
          WIN_SIZE="Unknown"
        fi
        echo "win_build_size=$WIN_SIZE" >> $GITHUB_OUTPUT
        
        LINUX_EXE=$(find release-assets -path "*/proxy-app-build-Linux-*/proxy_app" -type f | head -1)
        if [ -n "$LINUX_EXE" ]; then
          LINUX_SIZE=$(du -sh "$LINUX_EXE" | cut -f1)
        else
          LINUX_SIZE="Unknown"
        fi
        echo "linux_build_size=$LINUX_SIZE" >> $GITHUB_OUTPUT

        MACOS_EXE=$(find release-assets -path "*/proxy-app-build-macOS-*/proxy_app" -type f | head -1)
        if [ -n "$MACOS_EXE" ]; then
          MACOS_SIZE=$(du -sh "$MACOS_EXE" | cut -f1)
        else
          MACOS_SIZE="Unknown"
        fi
        echo "macos_build_size=$MACOS_SIZE" >> $GITHUB_OUTPUT

        COMMIT_COUNT=$(git rev-list --count HEAD)
        
        # Generate rich contributor list
        if [ -n "${{ steps.changelog.outputs.previous_tag }}" ]; then
          echo "✅ Found previous tag, getting contributors since ${{ steps.changelog.outputs.previous_tag }}"
          CONTRIBUTOR_LOG=$(git log ${{ steps.changelog.outputs.previous_tag }}..HEAD --format='%ae' | sort -u)
        else
          echo "⚠️ No previous tag found, getting author of the last commit."
          CONTRIBUTOR_LOG=$(git log -1 --format='%ae')
        fi
        CONTRIBUTORS_LIST=""
        while read -r email; do
          # Find user by email
          USER_INFO=$(gh api "search/users?q=$email+in:email" --jq '.items[0]')
          if [ -n "$USER_INFO" ]; then
            USERNAME=$(echo "$USER_INFO" | jq -r '.login')
            AVATAR_URL=$(echo "$USER_INFO" | jq -r '.avatar_url')
            CONTRIBUTORS_LIST="$CONTRIBUTORS_LIST [![$USERNAME](https://images.weserv.nl/?url=$AVATAR_URL&w=32&h=32&fit=cover&mask=circle)](https://github.com/$USERNAME) "
          fi
        done <<< "$CONTRIBUTOR_LOG"
        
        echo "commit_count=$COMMIT_COUNT" >> $GITHUB_OUTPUT
        echo "contributors_list=$CONTRIBUTORS_LIST" >> $GITHUB_OUTPUT
        
        echo "📊 Build metadata:"
        echo "  - Size (Windows): $WIN_SIZE"
        echo "  - Size (Linux): $LINUX_SIZE"
        echo "  - Size (macOS): $MACOS_SIZE"
        echo "  - Commits: $COMMIT_COUNT"
        echo "  - Contributors: $CONTRIBUTORS_LIST"

    - name: Create Release
      shell: bash
      run: |
        # Prepare changelog content
        if [ "${{ steps.changelog.outputs.has_changelog }}" == "true" ]; then
          echo "${{ steps.changelog.outputs.changelog_b64 }}" | base64 -d > decoded_changelog.md
          CHANGELOG_CONTENT=$(cat decoded_changelog.md)
        else
          CHANGELOG_CONTENT="No significant changes detected in this release."
        fi

        # Prepare the full release notes in a temporary file
        if [ -n "${{ steps.changelog.outputs.previous_tag }}" ]; then
          CHANGELOG_URL="**Full Changelog**: https://github.com/${{ github.repository }}/compare/${{ steps.changelog.outputs.previous_tag }}...${{ steps.version.outputs.release_tag }}"
        else
          CHANGELOG_URL=""
        fi

        # Generate file table
        FILE_TABLE="| OS | File | Description |\n|----|------|-------------|\n"
        WINDOWS_ARCHIVE=$(echo "${{ steps.archive.outputs.ASSET_PATHS }}" | tr ' ' '\n' | grep 'Windows')
        LINUX_ARCHIVE=$(echo "${{ steps.archive.outputs.ASSET_PATHS }}" | tr ' ' '\n' | grep 'Linux')
        MACOS_ARCHIVE=$(echo "${{ steps.archive.outputs.ASSET_PATHS }}" | tr ' ' '\n' | grep 'macOS')
        FILE_TABLE="$FILE_TABLE| Windows | \`$WINDOWS_ARCHIVE\` | Contains \`proxy_app.exe\` and \`launcher.bat\` | \n"
        FILE_TABLE="$FILE_TABLE| Linux | \`$LINUX_ARCHIVE\` | Contains \`proxy_app\` and \`launcher.bat\` | \n"
        FILE_TABLE="$FILE_TABLE| macOS | \`$MACOS_ARCHIVE\` | Contains \`proxy_app\` and \`launcher.bat\` | \n"

        cat > releasenotes.md <<-EOF
        ## Build Information
        | Field | Value |
        |-------|-------|
        | 📦 **Version** | \`${{ steps.version.outputs.version }}\` |
        | 💾 **Binary Size (Win)** | \`${{ steps.metadata.outputs.win_build_size }}\` |
        | 💾 **Binary Size (Linux)** | \`${{ steps.metadata.outputs.linux_build_size }}\` |
        | 💾 **Binary Size (macOS)** | \`${{ steps.metadata.outputs.macos_build_size }}\` |
        | 🔗 **Commit** | [\`${{ steps.get_sha.outputs.sha }}\`](https://github.com/${{ github.repository }}/commit/${{ github.sha }}) |
        | 📅 **Build Date** | \`${{ steps.version.outputs.timestamp }}\` |
        | ⚡ **Trigger** | \`${{ github.event_name }}\` |

        ## 📋 What's Changed

        $CHANGELOG_CONTENT

        ### 📁 Included Files
        $FILE_TABLE

        ## 🔗 Useful Links
        - 📖 [Documentation](https://github.com/${{ github.repository }}/wiki)
        - 🐛 [Report Issues](https://github.com/${{ github.repository }}/issues)
        - 💬 [Discussions](https://github.com/${{ github.repository }}/discussions)
        - 🌟 [Star this repo](https://github.com/${{ github.repository }}) if you find it useful!

        ---
        
        > **Note**: This is an automated build release.

        $CHANGELOG_URL
        EOF

        # Set release flags and notes based on the branch
        CURRENT_BRANCH="${{ github.ref_name }}"
        PRERELEASE_FLAG=""
        LATEST_FLAG="--latest"
        EXPERIMENTAL_NOTE=""

        # Check if the current branch is in the comma-separated whitelist
        if ! [[ ",${{ env.WHITELISTED_BRANCHES }}," == *",$CURRENT_BRANCH,"* ]]; then
          PRERELEASE_FLAG="--prerelease"
          LATEST_FLAG="" # Do not mark non-whitelisted branches as 'latest'
          EXPERIMENTAL_NOTE=$(cat <<-EOF
        > | ⚠️ **EXPERIMENTAL BUILD** ⚠️ |
        > |:---------------------------:|
        > | This release is from the \`$CURRENT_BRANCH\` branch and is **highly unstable**. |
        > | It contains features that change frequently and may be removed without notice. |
        > | **Do not use in production environments.** |
        EOF
          )
        fi

        # Prepend the experimental note if it exists
        if [ -n "$EXPERIMENTAL_NOTE" ]; then
          echo -e "$EXPERIMENTAL_NOTE\n\n$(cat releasenotes.md)" > releasenotes.md
        fi
        
        # Create the release using the notes file
        gh release create ${{ steps.version.outputs.release_tag }} \
          --target ${{ github.sha }} \
          --title "${{ steps.version.outputs.release_title }}" \
          --notes-file releasenotes.md \
          $LATEST_FLAG \
          $PRERELEASE_FLAG \
          ${{ steps.archive.outputs.ASSET_PATHS }}
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
